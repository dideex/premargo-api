# OpenAPI server library for Erlang

## Overview

An Erlang server stub generated by [OpenAPI Generator](https://openapi-generator.tech) given an OpenAPI spec.

## Prerequisites

1. [Erlang/OTP (v27)](https://www.erlang.org/)

2. [rebar3](https://rebar3.org/)

3. Erlang libraries:
    - [Cowboy](https://hex.pm/packages/cowboy)
    - [Ranch](https://hex.pm/packages/ranch)
    - [Jesse](https://hex.pm/packages/jesse)

4. OpenAPI generator script `openapi-generator-cli` 
(for more information see [OpenAPI Generator - Getting Started](https://github.com/OpenAPITools/openapi-generator#2---getting-started) )

5. OpenAPI specification file in the current folder (for example [petstore.yaml](https://raw.githubusercontent.com/openapitools/openapi-generator/master/modules/openapi-generator/src/test/resources/3_0/petstore.yaml))


## Getting started
Use `erlang-server` with `rebar3`

1. Create a folder with an Erlang application by using `rebar3`
    
    `$ rebar3 new app http_server`

2. Update your `rebar.config` to include the OpenAPI library as a dependency:

```erlang
{deps, [
    {openapi, {git, "https://github.com/dideex/premargo-api", {tag, "erl-1.0.5b"}}}
]}.
```

3. Erlang Server Configuration

The generated Erlang server provides a `start/2` function with the following options:

```erlang
start(ID, Params) -> {ok, pid()} | {error, any()}
```

Where `Params` is a map with the following options:

- `transport`: The transport protocol to use (`tcp` or `ssl`)
- `transport_opts`: Transport options for Ranch (the underlying connection handler)
- `swagger_json_handler`: Handler for serving the OpenAPI specification
- `protocol_opts`: Protocol options for Cowboy (the HTTP server)
- `service_routes`: Additional routes to add to the server
- `logic_handler`: Module implementing the business logic (defaults to `{packageName}_logic_handler`)

Example usage:

```erlang
{ok, _} = my_api_server:start(http, #{
    transport => tcp,
    transport_opts => #{port => 8080},
    logic_handler => my_custom_logic_handler
}).
```

4. Logic Handler Callbacks

The server requires a logic handler module that implements the `openapi_logic_handler` behaviour. This module is responsible for implementing the business logic for each API operation. The following callbacks must be implemented:

### Required Callbacks

#### `accept_callback/4`

```erlang
accept_callback(Class, OperationID, Req, Context) -> 
    {Code, Response, Req, Context}
```

This callback is called when a request is received. It should:
- Validate the request
- Return a response code (200-599)
- Return a response body or `stop` to indicate the request should not be processed further
- Return the updated request and context

#### `provide_callback/4`

```erlang
provide_callback(Class, OperationID, Req, Context) -> 
    {Code, Response, Req, Context}
```

This callback is called when a response is being generated. It should:
- Generate the appropriate response
- Return a response code (200-599)
- Return a response body or `stop` to indicate the response should not be processed further
- Return the updated request and context

### Optional Callbacks

#### `forbidden_callback/4`

```erlang
forbidden_callback(Class, OperationID, Req, Context) -> 
    {IsForbidden, Req, Context}
```

This callback is called to check if a request should be forbidden. It should:
- Return `{true, Req, Context}` if the request should be forbidden
- Return `{false, Req, Context}` if the request should be allowed

#### `validate_response/5`

```erlang
validate_response(Class, OperationID, Code, Response, State) -> 
    ok | no_return()
```

This callback is called to validate a response before it is sent. It should:
- Validate the response against the OpenAPI specification
- Return `ok` if the response is valid
- Throw an error if the response is invalid

### Example Logic Handler

```erlang
-module(my_logic_handler).
-behaviour(openapi_logic_handler).

-export([accept_callback/4, provide_callback/4]).

accept_callback(Class, OperationID, Req, Context) ->
    % Implement your business logic here
    {200, #{<<"message">> => <<"Request accepted">>}, Req, Context}.

provide_callback(Class, OperationID, Req, Context) ->
    % Implement your business logic here
    {200, #{<<"message">> => <<"Response provided">>}, Req, Context}.
```

5. Compile and Run

Compile your project:

```bash
$ rebar3 compile
```

Start the Erlang shell:

```bash
$ rebar3 shell
```

Start your application:

```erlang
1> application:ensure_all_started(http_server).
```

Your OpenAPI server should now be running and ready to accept requests! 