# OpenAPI server library for Erlang

## Overview

An Erlang server stub generated by [OpenAPI Generator](https://openapi-generator.tech) given an OpenAPI spec.

## Prerequisites

1. [Erlang/OTP (v27)](https://www.erlang.org/)

2. [rebar3](https://rebar3.org/)

3. Erlang libraries:
    - [Cowboy](https://hex.pm/packages/cowboy)
    - [Ranch](https://hex.pm/packages/ranch)
    - [Jesse](https://hex.pm/packages/jesse)

4. OpenAPI generator script `openapi-generator-cli` 
(for more information see [OpenAPI Generator - Getting Started](https://github.com/OpenAPITools/openapi-generator#2---getting-started) )

5. OpenAPI specification file in the current folder (for example [petstore.yaml](https://raw.githubusercontent.com/openapitools/openapi-generator/master/modules/openapi-generator/src/test/resources/3_0/petstore.yaml))


## Getting started
Use `erlang-server` with `rebar3`

1. Create a folder with an Erlang application by using `rebar3`
    
    `$ rebar3 new app http_server`

2. Update your `rebar.config` to include the OpenAPI library as a dependency:

```erlang
{deps, [
    {openapi, {git, "https://github.com/dideex/premargo-api", {tag, "erl-1.0.5b"}}}
]}.
```

3. Erlang Server Configuration

The generated Erlang server provides a `start/2` function with the following options:

```erlang
start(ID, Params) -> {ok, pid()} | {error, any()}
```

Where `Params` is a map with the following options:

- `transport`: The transport protocol to use (`tcp` or `ssl`)
- `transport_opts`: Transport options for Ranch (the underlying connection handler)
- `swagger_json_handler`: Handler for serving the OpenAPI specification
- `protocol_opts`: Protocol options for Cowboy (the HTTP server)
- `service_routes`: Additional routes to add to the server
- `logic_handler`: Module implementing the business logic (defaults to `{packageName}_logic_handler`)

Example usage:

```erlang
{ok, _} = my_api_server:start(http, #{
    transport => tcp,
    transport_opts => #{port => 8080},
    logic_handler => my_custom_logic_handler
}).
```

4. Logic Handler Callbacks

The server requires a logic handler module that implements the `openapi_logic_handler` behaviour. This module is responsible for implementing the business logic for each API operation.

### Required Callbacks

#### `handle_callback/3`

```erlang
-spec handle_callback(operation_id(), context(), opts()) ->
    {code(), handle_callback_return(), context(), opts()}.
```

This callback is called when a request is received. It should:
- Process the request and execute the business logic
- Return a response code (one of the defined codes in the module)
- Return a response body or `stop` to indicate the request should not be processed further
- Return the updated context and options

Parameters:
- `operation_id()`: The OpenAPI operation ID
- `context()`: A map containing the request context
- `opts()`: A map containing request metadata, including `req` which is the Cowboy request

Returns:
- `{code(), handle_callback_return(), context(), opts()}`
  - `code()`: One of `ok | created | accepted | moved_permanently | found | see_other | bad_request | unauthorized | forbidden | not_found | method_not_allowed`
  - `handle_callback_return()`: Either a response (map or list) or the atom `stop`

### Optional Callbacks

#### `forbidden_callback/3`

```erlang
-spec forbidden_callback(operation_id(), context(), opts()) ->
    {boolean(), context(), opts()}.
```

This callback is called to check if a request should be forbidden. It should:
- Return `{true, Context, Opts}` if the request should be forbidden
- Return `{false, Context, Opts}` if the request should be allowed

#### `validate_response/4`

```erlang
-spec validate_response(operation_id(), code(), response(), jesse_state:state()) ->
    ok | no_return().
```

This callback is called to validate a response before it is sent. It should:
- Validate the response against the OpenAPI specification
- Return `ok` if the response is valid
- Throw an error if the response is invalid

#### `response_encoder/2`

```erlang
-spec response_encoder(operation_id(), response()) ->
    iodata().
```

This callback is called to encode the response for the HTTP layer. It should:
- Convert the response into a format suitable for sending over HTTP
- Return an iodata() compatible value

#### `custom_type_validator/3`

```erlang
-spec custom_type_validator(rule(), Value, Name) ->
    ok | {ok, Value} | default | {wrong_param, rule(), Value, Name} | {error, iodata()}
    when Value :: term(), Name :: request_param().
```

This callback is called to validate request parameters with custom types. It should:
- Validate the provided value against the given rule
- Return `ok` or `{ok, Value}` if the value is valid
- Return `default` to use the default value
- Return `{wrong_param, Rule, Value, Name}` if the value is invalid
- Return `{error, iodata()}` in case you want to show custom error message

### Example Logic Handler

```erlang
-module(my_logic_handler).
-behaviour(openapi_logic_handler).

%% Required callbacks
-export([handle_callback/3]).

%% Optional callbacks
-export([forbidden_callback/3]).

handle_callback(OperationID, Context, Opts) ->
    % Implement your business logic here
    {ok, #{<<"message">> => <<"Request handled">>}, Context, Opts}.

forbidden_callback(_OperationID, Context, Opts) ->
    % Check if the request is allowed
    {false, Context, Opts}.
```

5. Compile and Run

Compile your project:

```bash
$ rebar3 compile
```

Start the Erlang shell:

```bash
$ rebar3 shell
```

Start your application:

```erlang
1> application:ensure_all_started(http_server).
```

Your OpenAPI server should now be running and ready to accept requests! 